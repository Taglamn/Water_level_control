<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>TestClickEvent</title>
</head>
<body>
<script src="js/three.min.js"></script>
<script src="orbitControlls.js"></script>
<script src="threeBSP.js"></script>
<script src="dat.gui.js"></script>
<script>
    var scene = new THREE.Scene();

    var camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 15000);

    var renderer = new THREE.WebGLRenderer();

    var controls = new THREE.OrbitControls(camera);

    var dat_controls = {
        水流失速度: 0.1,
        水供给速度: 1,
        水位控制最低高度: 9,
        供给至高度: 36,
        暂停: 0
    };
    var gui = new dat.GUI();
    var folder = gui.addFolder('菜单');
    gui.domElement.style ='position:absolute;top:0px;right:0px';
    folder.add(dat_controls, '水流失速度',0.1,10);
    folder.add(dat_controls, '水供给速度',0.1,10);
    folder.add(dat_controls, '水位控制最低高度',1,45);
    folder.add(dat_controls, '供给至高度',1,45);
    folder.add(dat_controls, '暂停',0,1).step(1);
    folder.open();

    var light = new THREE.AmbientLight(0xff0000, 0.2, 100, 2);
    light.position.set(0,100,0);
    scene.add(light);

    controls.enableDamping = true;

    renderer.setSize(window.innerWidth, window.innerHeight);

    document.body.appendChild(renderer.domElement);

    let loader = new THREE.TextureLoader();


    //let body = new THREE.Object3D();
    let box = new THREE.Object3D();
    box_tex = loader.load('img/timg2.jpg',function (texture) {
        texture.wrapS = floor_tex.wrapT = THREE.RepeatWrapping;
        texture.repeat.set(4,4);
        texture.transparent = true;
    });
    let floor_tex = loader.load('img/floor1.jpg',function (floor_tex) {
        floor_tex.wrapS = floor_tex.wrapT = THREE.RepeatWrapping;
        floor_tex.repeat.set(4,4);
    });
    //带洞
    let wall0 = new THREE.Mesh(
        new THREE.BoxGeometry(55, 5, 50),
        new THREE.MeshPhongMaterial({color : 0xffffff,transparent : true,opacity: 0.5,emissive : 0xffffff})
    );
    let wall1 = new THREE.Mesh(
        new THREE.BoxGeometry(45, 5, 45),
        new THREE.MeshPhongMaterial({color : 0xffffff,transparent : true,opacity: 0.5,emissive : 0xffffff})
    );

    wall1.position.x = 0;
    wall1.position.y = 25;
    wall1.position.z = -22.5;
    wall1.rotation.x = Math.PI/2;
    box.add(wall1);

    let wall2 = new THREE.Mesh(
        new THREE.BoxGeometry(45, 5, 45),
        new THREE.MeshPhongMaterial({color : 0xffffff,transparent : true,opacity: 0.5,emissive : 0xffffff})
    );

    wall2.position.x = 0;
    wall2.position.y = 25;
    wall2.position.z = 22.5;
    wall2.rotation.x = Math.PI/2;
    box.add(wall2);

    let wall3 = new THREE.Mesh(
        new THREE.BoxGeometry(45, 5, 50),
        new THREE.MeshPhongMaterial({transparent : true,opacity: 0.5,emissive : 0xffffff})
    );

    wall3.position.x = 25;
    wall3.position.y = 25;
    wall3.position.z = 0;
    wall3.rotation.z = Math.PI/2;
    box.add(wall3);

    let wall4 = new THREE.Mesh(
        new THREE.BoxGeometry(45, 5, 50),
        new THREE.MeshPhongMaterial({color : 0xffffff,transparent : true,opacity: 0.5,emissive : 0xffffff})
    );

    wall4.position.x = -25;
    wall4.position.y = 25;
    wall4.position.z = 0;
    wall4.rotation.z = Math.PI/2;
    box.add(wall4);


    let window1 = new THREE.Mesh(
        new THREE.CylinderGeometry(5, 5 ,5 ,40 ,40),
        new THREE.MeshPhongMaterial({color : 0xffffff,transparent : true,opacity: 0.5,emissive : 0xffffff})
    );

    let bsp_wall = new ThreeBSP(wall0);
    let bsp_window1 = new ThreeBSP(window1);
    //开始计算从bsp_wall减去bsp_window1后的BSP对象
    let BSP = bsp_wall.subtract(bsp_window1);
    //获取结算结果中的geometry对象
    let geometry = BSP.toMesh().geometry;
    //生成计算结果的几何体
    let res = new THREE.Mesh(
        geometry,
        new THREE.MeshPhongMaterial({color : 0xffffff,transparent : true,opacity: 0.5,emissive : 0xffffff})
    );
    //将几何体添加到场景中
    box.add(res);
    box.position.set(0,0,0);
    scene.add(box);


    function CustomSinCurve( scale ) {

        THREE.Curve.call( this );

        this.scale = ( scale === undefined ) ? 1 : scale;

    }

    CustomSinCurve.prototype = Object.create( THREE.Curve.prototype );
    CustomSinCurve.prototype.constructor = CustomSinCurve;

    CustomSinCurve.prototype.getPoint = function ( t ) {

        var tx = 0;
        var ty = t*3;
        var tz = 0;

        return new THREE.Vector3( tx, ty, tz ).multiplyScalar( this.scale );

    };

    var path = new CustomSinCurve( 10 );
    var geometry1 = new THREE.TubeGeometry( path, 20, 5, 80, false );
    var material1 = new THREE.MeshPhongMaterial({color : 0xffffff,transparent : true,opacity: 1,emissive : 0x888888})
    var mesh = new THREE.Mesh( geometry1, material1 );
    mesh.position.set(0,-30,0);
    scene.add( mesh );//管子

    var torus = new THREE.Mesh(new THREE.TorusGeometry(5, 5, 25, 80, Math.PI / 2),
        new THREE.MeshPhongMaterial({color : 0xffffff,transparent : true,opacity: 1,emissive : 0x888888})
    );
    torus.position.set(5,-30,0);
    torus.rotation.x = Math.PI;
    torus.rotation.y = Math.PI;
    scene.add(torus);

    let mesh1 = new THREE.Object3D();
    mesh1 = mesh.clone();
    mesh1.scale.set(1,3,1);
    mesh1.rotation.z = -Math.PI/2;
    mesh1.position.set(5,-35,0);
    scene.add(mesh1);

    var torus1 = new THREE.Object3D();
    torus1 = torus.clone();
    torus1.position.set(95,-30,0);
    torus1.rotation.x = Math.PI;
    torus1.rotation.y = 0;
    torus1.rotation.z = 0;
    scene.add(torus1);

    let mesh2 = new THREE.Object3D();
    mesh2 = mesh.clone();
    mesh2.position.set(100,-30,0);
    mesh2.scale.set(1,4,1);
    scene.add(mesh2);

    let bot_cap = new THREE.Mesh(new THREE.CylinderGeometry(5.5,5.5,10,40,40),new THREE.MeshBasicMaterial({}));
    let top_cap = new THREE.Mesh(new THREE.CylinderGeometry(5,5,19,40,40),new THREE.MeshBasicMaterial({}));
    top_cap.position.y = 5;
    let sector1_cap = new THREE.Mesh(new THREE.CylinderGeometry(2.5,2.5,14,40,40));
    sector1_cap.position.x = 2.5;
    let bsp_sector1 = new ThreeBSP(sector1_cap);

    let bsp_bot = new ThreeBSP(bot_cap);
    let bsp_top = new ThreeBSP(top_cap);
    //开始计算从bsp_wall减去bsp_window1后的BSP对象
    let BSP_cap = bsp_bot.subtract(bsp_top);
    BSP_cap = BSP_cap.subtract(bsp_sector1);

    //获取结算结果中的geometry对象
    let cap_geometry = BSP_cap.toMesh().geometry;
    //生成计算结果的几何体
    let cap_res = new THREE.Mesh(
        cap_geometry,
        new THREE.MeshPhongMaterial({color : 0xffffff,transparent : true,opacity: 0.5,emissive : 0xffffff})
    );
    //将几何体添加到场景中
    let Plug_g = new THREE.CylinderGeometry(2.5,2.5,0.1,40,40);
    let Plug = new THREE.Mesh(Plug_g,new THREE.MeshPhongMaterial({color : 0xffffff,transparent : true,opacity: 0.5,emissive : 0xffffff}));
    Plug.position.set(2.5,-0.5,0);
    scene.add(Plug);
    cap_res.position.set(0,-5,0);
    cap_res.rotation.z = Math.PI;
    scene.add(cap_res);

    let box1 = new THREE.Object3D();
    box1 = box.clone();
    box1.position.set(100,90,0);
    scene.add(box1);



    let floor_mat = new THREE.MeshBasicMaterial({map:floor_tex});

    let floor = new THREE.Mesh(new THREE.BoxGeometry(700,10,700),floor_mat);
    //let floor = new THREE.Mesh(new THREE.BoxGeometry(700,10,700),new THREE.MeshPhongMaterial({color:0x999999}));
    floor.position.set(0,-95,0);
    floor.material.map.wrapS = THREE.RepeatWrapping;
    floor.material.map.wrapT = THREE.RepeatWrapping;
    scene.add(floor);

    let room = new THREE.Object3D();
    var r_wall_tex = loader.load('img/f_wall.jpg',function (texture) {
        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
        texture.repeat.set(4,4);
    });
    let r_wall1 = new THREE.Mesh(
        new THREE.BoxGeometry(700, 50, 450),
        new THREE.MeshBasicMaterial({color:0xffffff,map:r_wall_tex})
    );

    r_wall1.position.y = 130;
    r_wall1.position.z = 350;
    r_wall1.rotation.x = Math.PI/2;
    room.add(r_wall1);

    let r_wall2 = new THREE.Mesh(
        new THREE.BoxGeometry(700, 50, 450),
        new THREE.MeshBasicMaterial({color:0xffffff,map:r_wall_tex})
    );

    r_wall2.position.y = 130;
    r_wall2.position.z = -350;
    r_wall2.rotation.x = Math.PI/2;
    room.add(r_wall2);

    let r_wall3 = new THREE.Mesh(
        new THREE.BoxGeometry(50, 450, 700),
        new THREE.MeshBasicMaterial({color:0xffffff,map:r_wall_tex})
    );

    r_wall3.position.x = 350;
    r_wall3.position.y = 130;
    room.add(r_wall3);

    let r_wall4 = new THREE.Mesh(
        new THREE.BoxGeometry(50, 450, 700),
        new THREE.MeshBasicMaterial({color:0xffffff,map:r_wall_tex})
    );

    r_wall4.position.x = -350;
    r_wall4.position.y = 130;
    r_wall4.material.map.wrapS = THREE.RepeatWrapping;
    r_wall4.material.map.wrapT = THREE.RepeatWrapping;
    room.add(r_wall4);

    scene.add(room);



    let water_using,water_unused;
    water_using = new THREE.Mesh(new THREE.BoxGeometry(45,45,40),new THREE.MeshPhongMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.5,
        emissive: 0x00f0ff
    }));
    water_using.position.y = 25;
    water_unused = new THREE.Object3D();
    water_unused = water_using.clone();
    water_unused.position.set(100,115,0);
    scene.add(water_using);
    scene.add(water_unused);

    var action_pau = {
        paused : function () {
            pause = 1-pause;
        }
    };

    camera.position.set(50,50,50);
    camera.lookAt({
        x:0,
        y:0,
        z:0
    });

    let i = 0,j = 0,lower=1,up=0,im,jm,pause = 1;
    function render() {
        im = dat_controls.水流失速度/100;
        jm = dat_controls.水供给速度/100;
        pause = dat_controls.暂停;
        controls.update();
        if (lower && pause) {
            i += im;
            if (i <= 1) {
                water_using.scale.set(1, 1 - i, 1);
                water_using.position.y -= 22.5 * im;
            }
        } else if (up && pause) {
            j += jm;
            if (j <= 1) {
                i = i + im - jm;
                water_using.scale.set(1, 1 - i, 1);
                water_unused.scale.set(1, 1 - j, 1);
                water_using.position.y += 22.5 * (jm - im);
                water_unused.position.y -= 22.5 * jm;
            }
        }
        if (i >= 1 - dat_controls.水位控制最低高度 / 45 && lower && pause) {
            lower = 0;
            up = 1;
        } else if ((i <= 1 - dat_controls.供给至高度 / 45 || j >= 1) && up && pause) {
            lower = 1;
            up = 0;
        }
        if (j >= 1)
            scene.remove(water_unused);
        if (i >= 1)
            scene.remove(water_using);

        renderer.render(scene, camera);
        requestAnimationFrame(render);
    }

    render();
</script>
</body>
</html>